## 垃圾收集
JavaScript具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。
垃圾收集机制的原理：找出那些不再继续使用的变量，然后释放其占用的内存。为此垃圾收集器会按照固定的时间间隔（或代码执行中预定的收集时间）,周期性地执行这一操作。
>函数中局部变量的正常生命周期：局部变量只在函数执行的过程中存在。而在这个过程中，会为局部变量在栈(或堆)内存上分配相应的空间，以便存储他们的值。然后在函数中使用这些变量，直至函数执行结束。此时，局部变量就没有存在的必要了，因此可以释放它们的内存以供将来使用。
垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存。用于标识无用变量的策略可能会因实现而异，但具体到浏览器中的实现，则通常有两个策略：

1. 标记清除
JavaScript中最常用的垃圾收集方式是标记清除。
- 当变量进入环境时，就将变量标记为“进入环境”，而当变量离开时，则将其标记为“离开环境”。
- 从逻辑上讲，永远不能释放进入环境的变量所占用的内存。因为只要执行流进入相应的环境，就可能会用到它们。
- 垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，最后垃圾收集器完成内存清除工作，销毁那些带标记的值并回收他们所占用的空间。
>到2008年为止，IE、Firefox、Opera、Chrome和Safari的JavaScript实现使用的都是标记清除式的垃圾收集策略，只不过垃圾收集的时间间隔互有不同。

2. 引用计数
引用计数是一种不太常见的垃圾收集策略。 它的含义是跟踪记录每个值被引用的次数。
- 当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1.
- 如果同一个值又被赋给另一个变量，则该值的引用次数加1.
- 相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1.
- 当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因此就可以将其占用的内存空间回收回来。

### 性能问题
垃圾收集器是周期性运行的，而且如果为变量分配的内存数量很大，那么回收工作量也是相当大的，这种情况下，确定垃圾收集的时间间隔是一个非常重要的问题。

### 管理内存
JavaScript在进行内存管理及垃圾收集时面临的主要问题是：分配给Web浏览器的可用内存数量通常要比分配给桌面应用程序的少。
>目的是防止运行JavaScript的网页耗尽全部系统内存而导致系统崩溃。
内存限制问题不仅会影响给变量分配内存，同时还会影响调用栈以及在一个线程中能够同时执行的语句数量。
因此，确保占用最少的内存可以让页面获得更好的性能。

优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。一旦数据不再有用，最好通过将其值设置为null来释放其引用——这个做法叫做解除引用。
这一做法适用于大多数全局变量和全局对象的属性，局部变量会在它们离开执行环境时自动被解除引用。

    function createPerson(name) {
        var localPerson = new Object();
        localPerson.name = name;
        return localPerson;
    }
    var globalPerson = createPerson("Nicholas");
    //手工解除globalPerson的引用
    globalPerson = null;

>解除一个值的引用并不意味着自动回收该值所占用的内存，解除引用的真正作用是让值脱离执行环境，以便来收集器下次运行时将其回收。
